"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const from_string_1 = require("./from-string");
const from_array_1 = require("./from-array");
const regex_1 = require("../parse/regex");
const token_1 = require("../parse/token");
const format_1 = require("../format/format");
const check_overflow_1 = require("./check-overflow");
const constants_1 = require("../units/constants");
const hooks_1 = require("../utils/hooks");
const parsing_flags_1 = require("./parsing-flags");
// constant that refers to the ISO standard
hooks_1.hooks.ISO_8601 = function () { };
// constant that refers to the RFC 2822 form
hooks_1.hooks.RFC_2822 = function () { };
// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks_1.hooks.ISO_8601) {
        from_string_1.configFromISO(config);
        return;
    }
    if (config._f === hooks_1.hooks.RFC_2822) {
        from_string_1.configFromRFC2822(config);
        return;
    }
    config._a = [];
    parsing_flags_1.default(config).empty = true;
    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i, i, parsedInput, tokens, token, skipped, stringLength = string.length, totalParsedInputLength = 0;
    tokens = format_1.expandFormat(config._f, config._locale).match(format_1.formattingTokens) || [];
    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(regex_1.getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                parsing_flags_1.default(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (format_1.formatTokenFunctions[token]) {
            if (parsedInput) {
                parsing_flags_1.default(config).empty = false;
            }
            else {
                parsing_flags_1.default(config).unusedTokens.push(token);
            }
            token_1.addTimeToArrayFromToken(token, parsedInput, config);
        }
        else if (config._strict && !parsedInput) {
            parsing_flags_1.default(config).unusedTokens.push(token);
        }
    }
    // add remaining unparsed input length to the string
    parsing_flags_1.default(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        parsing_flags_1.default(config).unusedInput.push(string);
    }
    // clear _12h flag if hour is <= 12
    if (config._a[constants_1.HOUR] <= 12 &&
        parsing_flags_1.default(config).bigHour === true &&
        config._a[constants_1.HOUR] > 0) {
        parsing_flags_1.default(config).bigHour = undefined;
    }
    parsing_flags_1.default(config).parsedDateParts = config._a.slice(0);
    parsing_flags_1.default(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[constants_1.HOUR] = meridiemFixWrap(config._locale, config._a[constants_1.HOUR], config._meridiem);
    from_array_1.configFromArray(config);
    check_overflow_1.default(config);
}
exports.configFromStringAndFormat = configFromStringAndFormat;
function meridiemFixWrap(locale, hour, meridiem) {
    var isPm;
    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    }
    else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    }
    else {
        // this is not supposed to happen
        return hour;
    }
}
//# sourceMappingURL=from-string-and-format.js.map