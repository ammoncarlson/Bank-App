"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constructor_1 = require("../moment/constructor");
const from_string_and_format_1 = require("./from-string-and-format");
const parsing_flags_1 = require("./parsing-flags");
const valid_1 = require("./valid");
const extend_1 = require("../utils/extend");
// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig, bestMoment, scoreToBeat, i, currentScore;
    if (config._f.length === 0) {
        parsing_flags_1.default(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }
    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = constructor_1.copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        from_string_and_format_1.configFromStringAndFormat(tempConfig);
        if (!valid_1.isValid(tempConfig)) {
            continue;
        }
        // if there is any input that was not parsed add a penalty for that format
        currentScore += parsing_flags_1.default(tempConfig).charsLeftOver;
        //or tokens
        currentScore += parsing_flags_1.default(tempConfig).unusedTokens.length * 10;
        parsing_flags_1.default(tempConfig).score = currentScore;
        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }
    extend_1.default(config, bestMoment || tempConfig);
}
exports.configFromStringAndArray = configFromStringAndArray;
//# sourceMappingURL=from-string-and-array.js.map