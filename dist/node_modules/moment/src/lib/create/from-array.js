"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const hooks_1 = require("../utils/hooks");
const date_from_array_1 = require("./date-from-array");
const year_1 = require("../units/year");
const week_calendar_utils_1 = require("../units/week-calendar-utils");
const constants_1 = require("../units/constants");
const local_1 = require("./local");
const defaults_1 = require("../utils/defaults");
const parsing_flags_1 = require("./parsing-flags");
function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks_1.hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}
// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray(config) {
    var i, date, input = [], currentDate, expectedWeekday, yearToUse;
    if (config._d) {
        return;
    }
    currentDate = currentDateArray(config);
    //compute day of the year from weeks and weekdays
    if (config._w && config._a[constants_1.DATE] == null && config._a[constants_1.MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }
    //if the day of the year is set, figure out what it is
    if (config._dayOfYear != null) {
        yearToUse = defaults_1.default(config._a[constants_1.YEAR], currentDate[constants_1.YEAR]);
        if (config._dayOfYear > year_1.daysInYear(yearToUse) || config._dayOfYear === 0) {
            parsing_flags_1.default(config)._overflowDayOfYear = true;
        }
        date = date_from_array_1.createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[constants_1.MONTH] = date.getUTCMonth();
        config._a[constants_1.DATE] = date.getUTCDate();
    }
    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }
    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }
    // Check for 24:00:00.000
    if (config._a[constants_1.HOUR] === 24 &&
        config._a[constants_1.MINUTE] === 0 &&
        config._a[constants_1.SECOND] === 0 &&
        config._a[constants_1.MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[constants_1.HOUR] = 0;
    }
    config._d = (config._useUTC ? date_from_array_1.createUTCDate : date_from_array_1.createDate).apply(null, input);
    expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();
    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }
    if (config._nextDay) {
        config._a[constants_1.HOUR] = 24;
    }
    // check for mismatching day of week
    if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
        parsing_flags_1.default(config).weekdayMismatch = true;
    }
}
exports.configFromArray = configFromArray;
function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;
        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults_1.default(w.GG, config._a[constants_1.YEAR], week_calendar_utils_1.weekOfYear(local_1.createLocal(), 1, 4).year);
        week = defaults_1.default(w.W, 1);
        weekday = defaults_1.default(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    }
    else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;
        var curWeek = week_calendar_utils_1.weekOfYear(local_1.createLocal(), dow, doy);
        weekYear = defaults_1.default(w.gg, config._a[constants_1.YEAR], curWeek.year);
        // Default to current week.
        week = defaults_1.default(w.w, curWeek.week);
        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        }
        else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        }
        else {
            // default to begining of week
            weekday = dow;
        }
    }
    if (week < 1 || week > week_calendar_utils_1.weeksInYear(weekYear, dow, doy)) {
        parsing_flags_1.default(config)._overflowWeeks = true;
    }
    else if (weekdayOverflow != null) {
        parsing_flags_1.default(config)._overflowWeekday = true;
    }
    else {
        temp = week_calendar_utils_1.dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[constants_1.YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}
//# sourceMappingURL=from-array.js.map