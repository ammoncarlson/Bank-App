"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const get_set_1 = require("../moment/get-set");
const has_own_prop_1 = require("../utils/has-own-prop");
const format_1 = require("../format/format");
const aliases_1 = require("./aliases");
const priorities_1 = require("./priorities");
const regex_1 = require("../parse/regex");
const token_1 = require("../parse/token");
const hooks_1 = require("../utils/hooks");
const constants_1 = require("./constants");
const to_int_1 = require("../utils/to-int");
const is_array_1 = require("../utils/is-array");
const is_number_1 = require("../utils/is-number");
const mod_1 = require("../utils/mod");
const index_of_1 = require("../utils/index-of");
const utc_1 = require("../create/utc");
const parsing_flags_1 = require("../create/parsing-flags");
const year_1 = require("../units/year");
function daysInMonth(year, month) {
    if (isNaN(year) || isNaN(month)) {
        return NaN;
    }
    var modMonth = mod_1.default(month, 12);
    year += (month - modMonth) / 12;
    return modMonth === 1 ? (year_1.isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
}
exports.daysInMonth = daysInMonth;
// FORMATTING
format_1.addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});
format_1.addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});
format_1.addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});
// ALIASES
aliases_1.addUnitAlias('month', 'M');
// PRIORITY
priorities_1.addUnitPriority('month', 8);
// PARSING
regex_1.addRegexToken('M', regex_1.match1to2);
regex_1.addRegexToken('MM', regex_1.match1to2, regex_1.match2);
regex_1.addRegexToken('MMM', function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
regex_1.addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});
token_1.addParseToken(['M', 'MM'], function (input, array) {
    array[constants_1.MONTH] = to_int_1.default(input) - 1;
});
token_1.addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[constants_1.MONTH] = month;
    }
    else {
        parsing_flags_1.default(config).invalidMonth = input;
    }
});
// LOCALES
var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
exports.defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths(m, format) {
    if (!m) {
        return is_array_1.default(this._months) ? this._months :
            this._months['standalone'];
    }
    return is_array_1.default(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}
exports.localeMonths = localeMonths;
exports.defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort(m, format) {
    if (!m) {
        return is_array_1.default(this._monthsShort) ? this._monthsShort :
            this._monthsShort['standalone'];
    }
    return is_array_1.default(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}
exports.localeMonthsShort = localeMonthsShort;
function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = utc_1.createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }
    if (strict) {
        if (format === 'MMM') {
            ii = index_of_1.default.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
        else {
            ii = index_of_1.default.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
    else {
        if (format === 'MMM') {
            ii = index_of_1.default.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = index_of_1.default.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
        else {
            ii = index_of_1.default.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = index_of_1.default.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}
function localeMonthsParse(monthName, format, strict) {
    var i, mom, regex;
    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }
    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }
    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = utc_1.createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        }
        else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        }
        else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}
exports.localeMonthsParse = localeMonthsParse;
// MOMENTS
function setMonth(mom, value) {
    var dayOfMonth;
    if (!mom.isValid()) {
        // No op
        return mom;
    }
    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = to_int_1.default(value);
        }
        else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!is_number_1.default(value)) {
                return mom;
            }
        }
    }
    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}
exports.setMonth = setMonth;
function getSetMonth(value) {
    if (value != null) {
        setMonth(this, value);
        hooks_1.hooks.updateOffset(this, true);
        return this;
    }
    else {
        return get_set_1.get(this, 'Month');
    }
}
exports.getSetMonth = getSetMonth;
function getDaysInMonth() {
    return daysInMonth(this.year(), this.month());
}
exports.getDaysInMonth = getDaysInMonth;
var defaultMonthsShortRegex = regex_1.matchWord;
function monthsShortRegex(isStrict) {
    if (this._monthsParseExact) {
        if (!has_own_prop_1.default(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        }
        else {
            return this._monthsShortRegex;
        }
    }
    else {
        if (!has_own_prop_1.default(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}
exports.monthsShortRegex = monthsShortRegex;
var defaultMonthsRegex = regex_1.matchWord;
function monthsRegex(isStrict) {
    if (this._monthsParseExact) {
        if (!has_own_prop_1.default(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        }
        else {
            return this._monthsRegex;
        }
    }
    else {
        if (!has_own_prop_1.default(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    }
}
exports.monthsRegex = monthsRegex;
function computeMonthsParse() {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }
    var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = utc_1.createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regex_1.regexEscape(shortPieces[i]);
        longPieces[i] = regex_1.regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regex_1.regexEscape(mixedPieces[i]);
    }
    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}
//# sourceMappingURL=month.js.map