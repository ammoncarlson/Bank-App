"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constructor_1 = require("./constructor");
const aliases_1 = require("../units/aliases");
const local_1 = require("../create/local");
const is_undefined_1 = require("../utils/is-undefined");
function isAfter(input, units) {
    var localInput = constructor_1.isMoment(input) ? input : local_1.createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = aliases_1.normalizeUnits(!is_undefined_1.default(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    }
    else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}
exports.isAfter = isAfter;
function isBefore(input, units) {
    var localInput = constructor_1.isMoment(input) ? input : local_1.createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = aliases_1.normalizeUnits(!is_undefined_1.default(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    }
    else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}
exports.isBefore = isBefore;
function isBetween(from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}
exports.isBetween = isBetween;
function isSame(input, units) {
    var localInput = constructor_1.isMoment(input) ? input : local_1.createLocal(input), inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = aliases_1.normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    }
    else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}
exports.isSame = isSame;
function isSameOrAfter(input, units) {
    return this.isSame(input, units) || this.isAfter(input, units);
}
exports.isSameOrAfter = isSameOrAfter;
function isSameOrBefore(input, units) {
    return this.isSame(input, units) || this.isBefore(input, units);
}
exports.isSameOrBefore = isSameOrBefore;
//# sourceMappingURL=compare.js.map