"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const deprecate_1 = require("../utils/deprecate");
const is_array_1 = require("../utils/is-array");
const local_1 = require("../create/local");
const valid_1 = require("../create/valid");
exports.prototypeMin = deprecate_1.deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
    var other = local_1.createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
        return other < this ? this : other;
    }
    else {
        return valid_1.createInvalid();
    }
});
exports.prototypeMax = deprecate_1.deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function () {
    var other = local_1.createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
        return other > this ? this : other;
    }
    else {
        return valid_1.createInvalid();
    }
});
// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && is_array_1.default(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return local_1.createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}
// TODO: Use [].sort instead?
function min() {
    var args = [].slice.call(arguments, 0);
    return pickBy('isBefore', args);
}
exports.min = min;
function max() {
    var args = [].slice.call(arguments, 0);
    return pickBy('isAfter', args);
}
exports.max = max;
//# sourceMappingURL=min-max.js.map