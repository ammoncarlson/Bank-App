"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constructor_1 = require("./constructor");
const is_number_1 = require("../utils/is-number");
const to_int_1 = require("../utils/to-int");
const abs_round_1 = require("../utils/abs-round");
const has_own_prop_1 = require("../utils/has-own-prop");
const constants_1 = require("../units/constants");
const offset_1 = require("../units/offset");
const local_1 = require("../create/local");
const valid_1 = require("./valid");
// ASP.NET json date format regex
var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;
// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function createDuration(input, key) {
    var duration = input, 
    // matching against regexp is expensive, do it on demand
    match = null, sign, ret, diffRes;
    if (constructor_1.isDuration(input)) {
        duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
        };
    }
    else if (is_number_1.default(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        }
        else {
            duration.milliseconds = input;
        }
    }
    else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y: 0,
            d: to_int_1.default(match[constants_1.DATE]) * sign,
            h: to_int_1.default(match[constants_1.HOUR]) * sign,
            m: to_int_1.default(match[constants_1.MINUTE]) * sign,
            s: to_int_1.default(match[constants_1.SECOND]) * sign,
            ms: to_int_1.default(abs_round_1.default(match[constants_1.MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    }
    else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;
        duration = {
            y: parseIso(match[2], sign),
            M: parseIso(match[3], sign),
            w: parseIso(match[4], sign),
            d: parseIso(match[5], sign),
            h: parseIso(match[6], sign),
            m: parseIso(match[7], sign),
            s: parseIso(match[8], sign)
        };
    }
    else if (duration == null) {
        duration = {};
    }
    else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(local_1.createLocal(duration.from), local_1.createLocal(duration.to));
        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }
    ret = new constructor_1.Duration(duration);
    if (constructor_1.isDuration(input) && has_own_prop_1.default(input, '_locale')) {
        ret._locale = input._locale;
    }
    return ret;
}
exports.createDuration = createDuration;
createDuration.fn = constructor_1.Duration.prototype;
createDuration.invalid = valid_1.createInvalid;
function parseIso(inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}
function positiveMomentsDifference(base, other) {
    var res = { milliseconds: 0, months: 0 };
    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }
    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
    return res;
}
function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return { milliseconds: 0, months: 0 };
    }
    other = offset_1.cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    }
    else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }
    return res;
}
//# sourceMappingURL=create.js.map